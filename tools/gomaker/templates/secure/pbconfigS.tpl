// Automatically generated by gomaker， DO NOT EDIT

{{/* 定义变量 */}}
{{$packageName := .PackageName}}
{{$sheetName := .SheetName}}
{{$pbname := .PBName}}
{{$isList := .IsList}}
{{$isStruct := .IsStruct}}
{{$map := .Map}}
{{$group := .Group}}
{{$max := .Max}}
{{$min := .Min}}
{{$sum := .Sum}}
{{$rangeList := .Range}}
{{$ast := .Ast}}
{{$isCheck := .IsCheck}}

package {{$packageName}}

import (
	"bytes"
	"fmt"
    "sync/atomic"

	pb "forevernine.com/planet/server/common/pbclass"
	"forevernine.com/planet/server/common/pbconfig/internal/manager"
	{{if or $sum $min $max $isCheck}} "forevernine.com/planet/server/common/pbconfig/internal/common/base" {{end}}
	{{if $isCheck}} "forevernine.com/planet/server/common/pbconfig/internal/common/check" {{end}}
    "github.com/gogo/protobuf/proto"
)

const TableSheetName = "{{$sheetName}}"
var _metaData atomic.Value

type MetaData struct {
{{if or $sum $min $max}} base.Analyzer {{end}}
	mCfgs []*pb.{{$pbname}}
    {{range $item := $map}} m{{$item.UniqueID}} map[string]*pb.{{$pbname}}
	{{end}} {{range $item := $group}} m{{$item.UniqueID}} map[string][]*pb.{{$pbname}}
	{{end}} 
}

func init() {
	manager.RegisterParser(TableSheetName, {{.Priority}}, parse, print)
	{{if $isCheck}} manager.RegisterCheckFunc(TableSheetName, checkItem) {{end}}
}

func metaData() *MetaData {
    return _metaData.Load().(*MetaData)
}

{{range $item := $map}} func {{$item.Index}}({{$item.Values.Arg}}) string {
    return fmt.Sprintf("{{$item.Format}}", {{$item.Values.Val ""}}) 
} {{end}} 

{{range $item := $group}} func {{$item.Index}}({{$item.Values.Arg}}) string {
    return fmt.Sprintf("{{$item.Format}}", {{$item.Values.Val ""}}) 
} {{end}} 

// 打印
func print(buf *bytes.Buffer) {
    for i, item := range metaData().mCfgs {
        buf.WriteString(fmt.Sprintf("%d: %s\n", i, item.ToProto().String()))
    } 
}

{{if $isCheck}} func checkItem(fileData proto.Unmarshaler) (rets []error) {
	hash := base.GetHash()
	tmp := base.GetMap()
	defer base.PutHash(hash)
	defer base.PutMap(tmp)
	if hash == nil || tmp == nil {
		return
	}
	msg, _ := fileData.(*pb.{{$sheetName}}ConfigAry)
    for index, item := range msg.Ary {
	{{range $item := $ast.Idents}} {{if $item.Type.IsReward}}
		rets = append(rets, check.RewardCheck(index+3, item.{{$item.Name}})...)
	{{end}} {{end}} {{range $item := $ast.Arrays}} {{if $item.Type.IsReward}} 
		rets = append(rets, check.RewardCheck(index+3, item.{{$item.Name}}...)...)
	{{end}} {{end}} {{range $item := $map}} check.AddIndex(tmp, {{$item.Index}}({{$item.Values.Val "item"}}), index+3)
    {{end}} check.AddRepeat(tmp, hash, item, index+3)
    }
    rets = append(rets, check.BaseCheck(tmp)...) 
    return
} {{end}}

// 配置解析
func parse(fileData proto.Unmarshaler) {
    msg, ok := fileData.(*pb.{{$sheetName}}ConfigAry)
    if !ok || msg == nil {
        panic("{{$sheetName}} is loaded failed")
    }
	metaData := &MetaData{
        {{range $item := $map}} m{{$item.UniqueID}}: make(map[string]*pb.{{$pbname}}),
	    {{end}} {{range $item := $group}} m{{$item.UniqueID}}: make(map[string][]*pb.{{$pbname}}),
		{{end}} mCfgs: make([]*pb.{{$pbname}}, len(msg.Ary)),
		{{if or $sum $min $max}} Analyzer: make(map[interface{}]int64), {{end}}
	}
    for i, v := range msg.Ary {
		vv := v.ToSecure()	
		metaData.mCfgs[i] = vv
		{{range $ss := $sum}} {{$tmp := index $ss.Values 0}} metaData.Sum(v.{{$tmp.Name}}, "{{$ss.UniqueID}}", nil)
		{{end}}	{{range $mm := $max}} {{$tmp := index $mm.Values 0}} metaData.Max(v.{{$tmp.Name}}, "{{$mm.UniqueID}}", nil) 
		{{end}} {{range $mm := $min}} {{$tmp := index $mm.Values 0}} metaData.Min(v.{{$tmp.Name}}, "{{$mm.UniqueID}}", nil) 
		{{end}} {{range $item := $map}} metaData.m{{$item.UniqueID}}[{{$item.Index}}({{$item.Values.Val "v"}})] = vv
	    {{end}} {{range $item := $group}} index := {{$item.Index}}({{$item.Values.Val "v"}}) 
			if _, ok := metaData.m{{$item.UniqueID}}[index]; !ok {
				metaData.m{{$item.UniqueID}}[index] = make([]*pb.{{$pbname}}, 0)
			}
			metaData.m{{$item.UniqueID}}[index] = append(metaData.m{{$item.UniqueID}}[index], vv)
			{{range $ss := $sum}} {{$tmp := index $ss.Values 0}} metaData.Sum(v.{{$tmp.Name}}, index, "{{$ss.UniqueID}}")
			{{end}} {{range $mm := $max}} {{$tmp := index $mm.Values 0}} metaData.Max(v.{{$tmp.Name}}, index, "{{$mm.UniqueID}}" ) 
			{{end}} {{range $mm := $min}} {{$tmp := index $mm.Values 0}} metaData.Min(v.{{$tmp.Name}}, index, "{{$mm.UniqueID}}") 
			{{end}}
	    {{end}} }
    _metaData.Store(metaData)
}

{{range $mm := $max}} func {{$mm.UniqueID}}() int64 {
	return metaData().Get("{{$mm.UniqueID}}", nil)
} {{end}} 

{{range $mm := $min}} func {{$mm.UniqueID}}() int64 {
	return metaData().Get("{{$mm.UniqueID}}", nil)
} {{end}} 

{{range $ss := $sum}} func {{$ss.UniqueID}}() int64 {
	return metaData().Get("{{$ss.UniqueID}}", nil)
} {{end}}	

{{range $g := $group}} 
{{range $mm := $max}} func {{$mm.UniqueID}}By{{$g.UniqueID}}({{$g.Values.Arg}}) int64 {
	return metaData().Get({{$g.Index}}({{$g.Values.Val ""}}), "{{$mm.UniqueID}}")
} {{end}} 

{{range $mm := $min}} func {{$mm.UniqueID}}By{{$g.UniqueID}}({{$g.Values.Arg}}) int64 {
	return metaData().Get({{$g.Index}}({{$g.Values.Val ""}}), "{{$mm.UniqueID}}")
} {{end}} 

{{range $ss := $sum}} func {{$ss.UniqueID}}By{{$g.UniqueID}}({{$g.Values.Arg}}) int64 {
	return metaData().Get({{$g.Index}}({{$g.Values.Val ""}}), "{{$ss.UniqueID}}")
} {{end}}
{{end}}

func Size() int {
    return len(metaData().mCfgs)
}

func Walk(f func(*pb.{{$pbname}})bool) {
    for _, item := range metaData().mCfgs {
		if f(item) {
			return
		}
    }
}

{{if $isStruct}} func Get() *pb.{{$pbname}} {
	return metaData().mCfgs[0]
} {{end}}

{{if $isList}} func Gets() (rets []*pb.{{$pbname}}) {
	if vals := metaData().mCfgs; len(vals) > 0 {
		rets = make([]*pb.{{$pbname}}, len(vals))
    	copy(rets, vals)
	}
	return
} {{end}}

{{range $m := $map}} func GetBy{{$m.UniqueID}}({{$m.Values.Arg}}) *pb.{{$pbname}} {
	return metaData().m{{$m.UniqueID}}[{{$m.Index}}({{$m.Values.Val ""}})]
} {{end}}

{{range $g := $group}} func GetsBy{{$g.UniqueID}}({{$g.Values.Arg}}) (rets []*pb.{{$pbname}}) {
	if vals, ok := metaData().m{{$g.UniqueID}}[{{$g.Index}}({{$g.Values.Val ""}})]; ok && len(vals) > 0 {
		rets = make([]*pb.{{$pbname}}, len(vals))
		copy(rets, vals)
	}
	return
}

func WalkBy{{$g.UniqueID}}({{$g.Values.Arg}}, f func(*pb.{{$pbname}})bool) {
	for _, val := range metaData().m{{$g.UniqueID}}[{{$g.Index}}({{$g.Values.Val ""}})] {
		if f(val) {
			return
		}
	}
} {{end}}

{{/* ----------------range接口-------------- */}}
{{range $item := $rangeList}} 
{{$min := index $item.Values 0}}
{{$max := index $item.Values 1}}
func Range{{$item.GetRange}}(val {{$min.Type}}, f func(val, min, max {{$min.Type}})bool) *pb.{{$pbname}} {
	if f == nil {
		f = func(val, min, max {{$min.Type}}) bool {
			return val >= min && val < max
		}
	}
    for _, item := range metaData().mCfgs {
		{{if $item.Field}} if f(val, item.Get{{$item.Field}}().Get{{$min.Name}}(), item.Get{{$item.Field}}().Get{{$max.Name}}()) {
			return item
		}
		{{else}} if f(val, item.Get{{$min.Name}}(), item.Get{{$max.Name}}()) {
			return item
		}
		{{end}}
    }
    return nil
}

{{range $g := $group}} //group类型
func Range{{$item.GetRange}}By{{$g.UniqueID}}({{$g.Values.Arg}}, val {{$min.Type}}, f func(val, min, max {{$min.Type}})bool) *pb.{{$pbname}} {
	if f == nil {
		f = func(val, min, max {{$min.Type}}) bool {
			return val >= min && val < max
		}
	}
	for _, item := range metaData().m{{$g.UniqueID}}[{{$g.Index}}({{$g.Values.Val ""}})] {
		{{if $item.Field}} if f(val, item.Get{{$item.Field}}().Get{{$min.Name}}(), item.Get{{$item.Field}}().Get{{$max.Name}}()) {
			return item
		}
		{{else}} if f(val, item.Get{{$min.Name}}(), item.Get{{$max.Name}}()) {
			return item
		}
		{{end}}
	}
	return nil
} 
{{end}} 
{{end}}