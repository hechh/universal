package main

import (
	"flag"
	"fmt"
	"path"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	showVersion := flag.Bool("version", false, "print version and exit")
	flag.Parse()
	if *showVersion {
		fmt.Println("protoc-gen-xorm v1.0.0")
		return
	}

	protogen.Options{
		ParamFunc: flag.CommandLine.Set,
	}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		// 解析命令行参数，获取输出目录
		outputDir := "."
		if param := gen.Request.GetParameter(); param != "" {
			params := strings.Split(param, ",")
			for _, p := range params {
				if strings.HasPrefix(p, "paths=") {
					// 处理 paths=source_relative 这样的参数
					continue
				}
				if idx := strings.Index(p, "="); idx > 0 {
					key, value := p[:idx], p[idx+1:]
					if key == "out" || key == "paths" {
						outputDir = value
					}
				}
			}
		}

		for _, file := range gen.Files {
			if !file.Generate || len(file.Messages) <= 0 {
				continue
			}
			generateFile(gen, file, outputDir)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File, outputDir string) {
	baseName := path.Base(file.GeneratedFilenamePrefix)
	filename := path.Join(outputDir, baseName+"_xorm.pb.go")
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	// 构建完整的输出文件名，包含目录

	// 文件头
	g.P("// Code generated by protoc-gen-go-xorm. DO NOT EDIT.")
	g.P("// Source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`  "github.com/golang/protobuf/proto"`)
	g.P(")")
	g.P()

	// 为每个消息生成XORM方法
	for _, message := range file.Messages {
		for _, field := range message.Fields {
			g.P("func (x *", message.GoIdent, ") Set", field.GoName, "(val ", getFieldType(field), ") {")
			g.P("  x.", field.GoName, " = val")
			g.P("}")
			g.P()
		}
		g.P("func (x *", message.GoIdent, ") FromDB(data []byte) error {")
		g.P("  if len(data) == 0 { return nil }")
		g.P("  return proto.Unmarshal(data, x)")
		g.P("}")
		g.P()
		g.P("func (x *", message.GoIdent, ") ToDB() ([]byte, error) {")
		g.P("  if x == nil { return nil, nil }")
		g.P("  return proto.Marshal(x)")
		g.P("}")
		g.P()
	}
}

func getFieldType(field *protogen.Field) string {
	// 处理map类型字段
	if field.Desc.IsMap() {
		keyType := getMapKeyType(field.Desc.MapKey())
		valueType := getMapValueType(field.Desc.MapValue())
		return fmt.Sprintf("map[%s]%s", keyType, valueType)
	}
	// 处理repeated字段（数组/切片）
	if field.Desc.IsList() {
		elementType := getSingleFieldType(field)
		return "[]" + elementType
	}
	return getSingleFieldType(field)
}

// 获取map的key类型
func getMapKeyType(field protoreflect.FieldDescriptor) string {
	switch field.Kind() {
	case protoreflect.StringKind:
		return "string"
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		return "int32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		return "int64"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		return "uint32"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		return "uint64"
	case protoreflect.BoolKind:
		return "bool"
	default:
		return "string" // 默认处理为string类型
	}
}

// 获取map的value类型
func getMapValueType(field protoreflect.FieldDescriptor) string {
	switch field.Kind() {
	case protoreflect.MessageKind:
		return "*" + string(field.Message().Name())
	case protoreflect.EnumKind:
		return string(field.Enum().Name())
	case protoreflect.BytesKind:
		return "[]byte"
	default:
		return field.Kind().String() // 基础类型（如int32, string等）
	}
}

// 处理非repeated字段的基础类型（保持不变）
func getSingleFieldType(field *protogen.Field) string {
	switch field.Desc.Kind() {
	case protoreflect.MessageKind:
		return "*" + field.Message.GoIdent.GoName
	case protoreflect.EnumKind:
		return field.Enum.GoIdent.GoName
	case protoreflect.BytesKind:
		return "[]byte"
	default:
		return field.Desc.Kind().String()
	}
}
